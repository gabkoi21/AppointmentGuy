{
  "version": 3,
  "sources": ["../../list/dist/es/index.js"],
  "sourcesContent": ["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar branchingFactor = 32;\nvar branchBits = 5;\nvar mask = 31;\nfunction isSetoid(a) {\n    return a && typeof a[\"fantasy-land/equals\"] === \"function\";\n}\nfunction elementEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else if (isSetoid(a)) {\n        return a[\"fantasy-land/equals\"](b);\n    }\n    else {\n        return false;\n    }\n}\nfunction createPath(depth, value) {\n    var current = value;\n    for (var i = 0; i < depth; ++i) {\n        current = new Node(undefined, [current]);\n    }\n    return current;\n}\nfunction copyArray(source) {\n    var array = [];\n    for (var i = 0; i < source.length; ++i) {\n        array[i] = source[i];\n    }\n    return array;\n}\nfunction pushElements(source, target, offset, amount) {\n    for (var i = offset; i < offset + amount; ++i) {\n        target.push(source[i]);\n    }\n}\nfunction copyIndices(source, sourceStart, target, targetStart, length) {\n    for (var i = 0; i < length; ++i) {\n        target[targetStart + i] = source[sourceStart + i];\n    }\n}\nfunction arrayPrepend(value, array) {\n    var newLength = array.length + 1;\n    var result = new Array(newLength);\n    result[0] = value;\n    for (var i = 1; i < newLength; ++i) {\n        result[i] = array[i - 1];\n    }\n    return result;\n}\nfunction reverseArray(array) {\n    return array.slice().reverse();\n}\nfunction arrayFirst(array) {\n    return array[0];\n}\nfunction arrayLast(array) {\n    return array[array.length - 1];\n}\nvar pathResult = { path: 0, index: 0, updatedOffset: 0 };\nfunction getPath(index, offset, depth, sizes) {\n    if (sizes === undefined && offset !== 0) {\n        pathResult.updatedOffset = 0;\n        index = handleOffset(depth, offset, index);\n    }\n    var path = (index >> (depth * branchBits)) & mask;\n    if (sizes !== undefined) {\n        while (sizes[path] <= index) {\n            path++;\n        }\n        var traversed = path === 0 ? 0 : sizes[path - 1];\n        index -= traversed;\n        pathResult.updatedOffset = offset;\n    }\n    pathResult.path = path;\n    pathResult.index = index;\n    return pathResult;\n}\nfunction updateNode(node, depth, index, offset, value) {\n    var _a = getPath(index, offset, depth, node.sizes), path = _a.path, newIndex = _a.index, updatedOffset = _a.updatedOffset;\n    var array = copyArray(node.array);\n    array[path] =\n        depth > 0\n            ? updateNode(array[path], depth - 1, newIndex, updatedOffset, value)\n            : value;\n    return new Node(node.sizes, array);\n}\nvar Node = (function () {\n    function Node(sizes, array) {\n        this.sizes = sizes;\n        this.array = array;\n    }\n    return Node;\n}());\nexport { Node };\nfunction cloneNode(_a) {\n    var sizes = _a.sizes, array = _a.array;\n    return new Node(sizes === undefined ? undefined : copyArray(sizes), copyArray(array));\n}\nvar emptyAffix = [0];\nvar affixBits = 6;\nvar affixMask = 63;\nfunction getSuffixSize(l) {\n    return l.bits & affixMask;\n}\nfunction getPrefixSize(l) {\n    return (l.bits >> affixBits) & affixMask;\n}\nfunction getDepth(l) {\n    return l.bits >> (affixBits * 2);\n}\nfunction setPrefix(size, bits) {\n    return (size << affixBits) | (bits & ~(affixMask << affixBits));\n}\nfunction setSuffix(size, bits) {\n    return size | (bits & ~affixMask);\n}\nfunction setDepth(depth, bits) {\n    return ((depth << (affixBits * 2)) | (bits & (affixMask | (affixMask << affixBits))));\n}\nfunction incrementPrefix(bits) {\n    return bits + (1 << affixBits);\n}\nfunction incrementSuffix(bits) {\n    return bits + 1;\n}\nfunction incrementDepth(bits) {\n    return bits + (1 << (affixBits * 2));\n}\nfunction decrementDepth(bits) {\n    return bits - (1 << (affixBits * 2));\n}\nvar List = (function () {\n    function List(bits, offset, length, prefix, root, suffix) {\n        this.bits = bits;\n        this.offset = offset;\n        this.length = length;\n        this.prefix = prefix;\n        this.root = root;\n        this.suffix = suffix;\n    }\n    List.prototype[Symbol.iterator] = function () {\n        return new ForwardListIterator(this);\n    };\n    List.prototype.toJSON = function () {\n        return toArray(this);\n    };\n    return List;\n}());\nexport { List };\nfunction cloneList(l) {\n    return new List(l.bits, l.offset, l.length, l.prefix, l.root, l.suffix);\n}\nvar ListIterator = (function () {\n    function ListIterator(l, direction) {\n        this.l = l;\n        this.result = { done: false, value: undefined };\n        this.idx = direction === 1 ? -1 : l.length;\n        this.prefixSize = getPrefixSize(l);\n        this.middleSize = l.length - getSuffixSize(l);\n        if (l.root !== undefined) {\n            var depth = getDepth(l);\n            this.stack = new Array(depth + 1);\n            this.indices = new Array(depth + 1);\n            var currentNode = l.root.array;\n            for (var i = depth; 0 <= i; --i) {\n                this.stack[i] = currentNode;\n                var idx = direction === 1 ? 0 : currentNode.length - 1;\n                this.indices[i] = idx;\n                currentNode = currentNode[idx].array;\n            }\n            this.indices[0] -= direction;\n        }\n    }\n    return ListIterator;\n}());\nvar ForwardListIterator = (function (_super) {\n    __extends(ForwardListIterator, _super);\n    function ForwardListIterator(l) {\n        return _super.call(this, l, 1) || this;\n    }\n    ForwardListIterator.prototype.nextInTree = function () {\n        for (var i = 0; ++this.indices[i] === this.stack[i].length; ++i) {\n            this.indices[i] = 0;\n        }\n        for (; 0 < i; --i) {\n            this.stack[i - 1] = this.stack[i][this.indices[i]].array;\n        }\n    };\n    ForwardListIterator.prototype.next = function () {\n        var newVal;\n        var idx = ++this.idx;\n        if (idx < this.prefixSize) {\n            newVal = this.l.prefix[this.prefixSize - idx - 1];\n        }\n        else if (idx < this.middleSize) {\n            this.nextInTree();\n            newVal = this.stack[0][this.indices[0]];\n        }\n        else if (idx < this.l.length) {\n            newVal = this.l.suffix[idx - this.middleSize];\n        }\n        else {\n            this.result.done = true;\n        }\n        this.result.value = newVal;\n        return this.result;\n    };\n    return ForwardListIterator;\n}(ListIterator));\nvar BackwardsListIterator = (function (_super) {\n    __extends(BackwardsListIterator, _super);\n    function BackwardsListIterator(l) {\n        return _super.call(this, l, -1) || this;\n    }\n    BackwardsListIterator.prototype.prevInTree = function () {\n        for (var i = 0; this.indices[i] === 0; ++i) { }\n        --this.indices[i];\n        for (; 0 < i; --i) {\n            var n = this.stack[i][this.indices[i]].array;\n            this.stack[i - 1] = n;\n            this.indices[i - 1] = n.length - 1;\n        }\n    };\n    BackwardsListIterator.prototype.next = function () {\n        var newVal;\n        var idx = --this.idx;\n        if (this.middleSize <= idx) {\n            newVal = this.l.suffix[idx - this.middleSize];\n        }\n        else if (this.prefixSize <= idx) {\n            this.prevInTree();\n            newVal = this.stack[0][this.indices[0]];\n        }\n        else if (0 <= idx) {\n            newVal = this.l.prefix[this.prefixSize - idx - 1];\n        }\n        else {\n            this.result.done = true;\n        }\n        this.result.value = newVal;\n        return this.result;\n    };\n    return BackwardsListIterator;\n}(ListIterator));\nexport function backwards(l) {\n    var _a;\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            return new BackwardsListIterator(l);\n        },\n        _a;\n}\nfunction emptyPushable() {\n    return new List(0, 0, 0, [], undefined, []);\n}\nfunction push(value, l) {\n    var suffixSize = getSuffixSize(l);\n    if (l.length === 0) {\n        l.bits = setPrefix(1, l.bits);\n        l.prefix = [value];\n    }\n    else if (suffixSize < 32) {\n        l.bits = incrementSuffix(l.bits);\n        l.suffix.push(value);\n    }\n    else if (l.root === undefined) {\n        l.root = new Node(undefined, l.suffix);\n        l.suffix = [value];\n        l.bits = setSuffix(1, l.bits);\n    }\n    else {\n        var newNode = new Node(undefined, l.suffix);\n        var index = l.length - 1 - 32 + 1;\n        var current = l.root;\n        var depth = getDepth(l);\n        l.suffix = [value];\n        l.bits = setSuffix(1, l.bits);\n        if (index - 1 < Math.pow(branchingFactor, (depth + 1))) {\n            for (; depth >= 0; --depth) {\n                var path = (index >> (depth * branchBits)) & mask;\n                if (path < current.array.length) {\n                    current = current.array[path];\n                }\n                else {\n                    current.array.push(createPath(depth - 1, newNode));\n                    break;\n                }\n            }\n        }\n        else {\n            l.bits = incrementDepth(l.bits);\n            l.root = new Node(undefined, [l.root, createPath(depth, newNode)]);\n        }\n    }\n    l.length++;\n    return l;\n}\nexport function list() {\n    var elements = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        elements[_i] = arguments[_i];\n    }\n    var l = emptyPushable();\n    for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {\n        var element = elements_1[_a];\n        push(element, l);\n    }\n    return l;\n}\nexport function empty() {\n    return new List(0, 0, 0, emptyAffix, undefined, emptyAffix);\n}\nexport function of(a) {\n    return list(a);\n}\nexport function pair(first, second) {\n    return new List(2, 0, 2, emptyAffix, undefined, [first, second]);\n}\nexport function from(sequence) {\n    var l = emptyPushable();\n    if (sequence.length > 0 && (sequence[0] !== undefined || 0 in sequence)) {\n        for (var i = 0; i < sequence.length; ++i) {\n            push(sequence[i], l);\n        }\n    }\n    else if (Symbol.iterator in sequence) {\n        var iterator = sequence[Symbol.iterator]();\n        var cur = void 0;\n        while (!(cur = iterator.next()).done) {\n            push(cur.value, l);\n        }\n    }\n    return l;\n}\nexport function range(start, end) {\n    var list = emptyPushable();\n    for (var i = start; i < end; ++i) {\n        push(i, list);\n    }\n    return list;\n}\nexport function repeat(value, times) {\n    var l = emptyPushable();\n    while (--times >= 0) {\n        push(value, l);\n    }\n    return l;\n}\nexport function times(func, times) {\n    var l = emptyPushable();\n    for (var i = 0; i < times; i++) {\n        push(func(i), l);\n    }\n    return l;\n}\nfunction nodeNthDense(node, depth, index) {\n    var current = node;\n    for (; depth >= 0; --depth) {\n        current = current.array[(index >> (depth * branchBits)) & mask];\n    }\n    return current;\n}\nfunction handleOffset(depth, offset, index) {\n    index += offset;\n    for (; depth >= 0; --depth) {\n        index = index - (offset & (mask << (depth * branchBits)));\n        if (((index >> (depth * branchBits)) & mask) !== 0) {\n            break;\n        }\n    }\n    return index;\n}\nfunction nodeNth(node, depth, offset, index) {\n    var path;\n    var current = node;\n    while (current.sizes !== undefined) {\n        path = (index >> (depth * branchBits)) & mask;\n        while (current.sizes[path] <= index) {\n            path++;\n        }\n        if (path !== 0) {\n            index -= current.sizes[path - 1];\n            offset = 0;\n        }\n        depth--;\n        current = current.array[path];\n    }\n    return nodeNthDense(current, depth, offset === 0 ? index : handleOffset(depth, offset, index));\n}\nexport function nth(index, l) {\n    if (index < 0 || l.length <= index) {\n        return undefined;\n    }\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    if (index < prefixSize) {\n        return l.prefix[prefixSize - index - 1];\n    }\n    else if (index >= l.length - suffixSize) {\n        return l.suffix[index - (l.length - suffixSize)];\n    }\n    var offset = l.offset;\n    var depth = getDepth(l);\n    return l.root.sizes === undefined\n        ? nodeNthDense(l.root, depth, offset === 0\n            ? index - prefixSize\n            : handleOffset(depth, offset, index - prefixSize))\n        : nodeNth(l.root, depth, offset, index - prefixSize);\n}\nfunction setSizes(node, height) {\n    var sum = 0;\n    var sizeTable = [];\n    for (var i = 0; i < node.array.length; ++i) {\n        sum += sizeOfSubtree(node.array[i], height - 1);\n        sizeTable[i] = sum;\n    }\n    node.sizes = sizeTable;\n    return node;\n}\nfunction sizeOfSubtree(node, height) {\n    if (height !== 0) {\n        if (node.sizes !== undefined) {\n            return arrayLast(node.sizes);\n        }\n        else {\n            var lastSize = sizeOfSubtree(arrayLast(node.array), height - 1);\n            return ((node.array.length - 1) << (height * branchBits)) + lastSize;\n        }\n    }\n    else {\n        return node.array.length;\n    }\n}\nfunction affixPush(a, array, length) {\n    if (array.length === length) {\n        array.push(a);\n        return array;\n    }\n    else {\n        var newArray = [];\n        copyIndices(array, 0, newArray, 0, length);\n        newArray.push(a);\n        return newArray;\n    }\n}\nexport function prepend(value, l) {\n    var prefixSize = getPrefixSize(l);\n    if (prefixSize < 32) {\n        return new List(incrementPrefix(l.bits), l.offset, l.length + 1, affixPush(value, l.prefix, prefixSize), l.root, l.suffix);\n    }\n    else {\n        var newList = cloneList(l);\n        prependNodeToTree(newList, reverseArray(l.prefix));\n        var newPrefix = [value];\n        newList.prefix = newPrefix;\n        newList.length++;\n        newList.bits = setPrefix(1, newList.bits);\n        return newList;\n    }\n}\nfunction copyLeft(l, k) {\n    var currentNode = cloneNode(l.root);\n    l.root = currentNode;\n    for (var i = 1; i < k; ++i) {\n        var index = 0;\n        if (currentNode.sizes !== undefined) {\n            for (var i_1 = 0; i_1 < currentNode.sizes.length; ++i_1) {\n                currentNode.sizes[i_1] += 32;\n            }\n        }\n        var newNode = cloneNode(currentNode.array[index]);\n        currentNode.array[index] = newNode;\n        currentNode = newNode;\n    }\n    return currentNode;\n}\nfunction nodePrepend(value, size, node) {\n    var array = arrayPrepend(value, node.array);\n    var sizes = undefined;\n    if (node.sizes !== undefined) {\n        sizes = new Array(node.sizes.length + 1);\n        sizes[0] = size;\n        for (var i = 0; i < node.sizes.length; ++i) {\n            sizes[i + 1] = node.sizes[i] + size;\n        }\n    }\n    return new Node(sizes, array);\n}\nfunction prependTopTree(l, depth, node) {\n    var newOffset;\n    if (l.root.array.length < branchingFactor) {\n        newOffset = Math.pow(32, depth) - 32;\n        l.root = new Node(undefined, arrayPrepend(createPath(depth - 1, node), l.root.array));\n    }\n    else {\n        l.bits = incrementDepth(l.bits);\n        var sizes = l.root.sizes === undefined\n            ? undefined\n            : [32, arrayLast(l.root.sizes) + 32];\n        newOffset = depth === 0 ? 0 : Math.pow(32, (depth + 1)) - 32;\n        l.root = new Node(sizes, [createPath(depth, node), l.root]);\n    }\n    return newOffset;\n}\nfunction prependNodeToTree(l, array) {\n    if (l.root === undefined) {\n        if (getSuffixSize(l) === 0) {\n            l.bits = setSuffix(array.length, l.bits);\n            l.suffix = array;\n        }\n        else {\n            l.root = new Node(undefined, array);\n        }\n        return l;\n    }\n    else {\n        var node = new Node(undefined, array);\n        var depth = getDepth(l);\n        var newOffset_1 = 0;\n        if (l.root.sizes === undefined) {\n            if (l.offset !== 0) {\n                newOffset_1 = l.offset - branchingFactor;\n                l.root = prependDense(l.root, depth, l.offset, node);\n            }\n            else {\n                newOffset_1 = prependTopTree(l, depth, node);\n            }\n        }\n        else {\n            var copyableCount = 0;\n            var nodesTraversed = 0;\n            var currentNode = l.root;\n            while (currentNode.sizes !== undefined && nodesTraversed < depth) {\n                ++nodesTraversed;\n                if (currentNode.array.length < 32) {\n                    copyableCount = nodesTraversed;\n                }\n                currentNode = currentNode.array[0];\n            }\n            if (l.offset !== 0) {\n                var copiedNode = copyLeft(l, nodesTraversed);\n                for (var i = 0; i < copiedNode.sizes.length; ++i) {\n                    copiedNode.sizes[i] += branchingFactor;\n                }\n                copiedNode.array[0] = prependDense(copiedNode.array[0], depth - nodesTraversed, l.offset, node);\n                l.offset = l.offset - branchingFactor;\n                return l;\n            }\n            else {\n                if (copyableCount === 0) {\n                    l.offset = prependTopTree(l, depth, node);\n                }\n                else {\n                    var parent_1;\n                    var prependableNode = void 0;\n                    if (copyableCount > 1) {\n                        parent_1 = copyLeft(l, copyableCount - 1);\n                        prependableNode = parent_1.array[0];\n                    }\n                    else {\n                        parent_1 = undefined;\n                        prependableNode = l.root;\n                    }\n                    var path = createPath(depth - copyableCount, node);\n                    l.offset = Math.pow(32, (depth - copyableCount + 1)) - 32;\n                    var prepended = nodePrepend(path, 32, prependableNode);\n                    if (parent_1 === undefined) {\n                        l.root = prepended;\n                    }\n                    else {\n                        parent_1.array[0] = prepended;\n                    }\n                }\n                return l;\n            }\n        }\n        l.offset = newOffset_1;\n        return l;\n    }\n}\nfunction prependDense(node, depth, offset, value) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = (((offset - 1) >> (depth * branchBits)) & mask) - curOffset;\n    if (path < 0) {\n        return new Node(undefined, arrayPrepend(createPath(depth - 1, value), node.array));\n    }\n    else {\n        var array = copyArray(node.array);\n        array[0] = prependDense(array[0], depth - 1, offset, value);\n        return new Node(undefined, array);\n    }\n}\nexport function append(value, l) {\n    var suffixSize = getSuffixSize(l);\n    if (suffixSize < 32) {\n        return new List(incrementSuffix(l.bits), l.offset, l.length + 1, l.prefix, l.root, affixPush(value, l.suffix, suffixSize));\n    }\n    var newSuffix = [value];\n    var newList = cloneList(l);\n    appendNodeToTree(newList, l.suffix);\n    newList.suffix = newSuffix;\n    newList.length++;\n    newList.bits = setSuffix(1, newList.bits);\n    return newList;\n}\nexport function length(l) {\n    return l.length;\n}\nexport function first(l) {\n    var prefixSize = getPrefixSize(l);\n    return prefixSize !== 0\n        ? l.prefix[prefixSize - 1]\n        : l.length !== 0\n            ? l.suffix[0]\n            : undefined;\n}\nexport var head = first;\nexport function last(l) {\n    var suffixSize = getSuffixSize(l);\n    return suffixSize !== 0\n        ? l.suffix[suffixSize - 1]\n        : l.length !== 0\n            ? l.prefix[0]\n            : undefined;\n}\nfunction mapArray(f, array) {\n    var result = new Array(array.length);\n    for (var i = 0; i < array.length; ++i) {\n        result[i] = f(array[i]);\n    }\n    return result;\n}\nfunction mapNode(f, node, depth) {\n    if (depth !== 0) {\n        var array = node.array;\n        var result = new Array(array.length);\n        for (var i = 0; i < array.length; ++i) {\n            result[i] = mapNode(f, array[i], depth - 1);\n        }\n        return new Node(node.sizes, result);\n    }\n    else {\n        return new Node(undefined, mapArray(f, node.array));\n    }\n}\nfunction mapPrefix(f, prefix, length) {\n    var newPrefix = new Array(length);\n    for (var i = length - 1; 0 <= i; --i) {\n        newPrefix[i] = f(prefix[i]);\n    }\n    return newPrefix;\n}\nfunction mapAffix(f, suffix, length) {\n    var newSuffix = new Array(length);\n    for (var i = 0; i < length; ++i) {\n        newSuffix[i] = f(suffix[i]);\n    }\n    return newSuffix;\n}\nexport function map(f, l) {\n    return new List(l.bits, l.offset, l.length, mapPrefix(f, l.prefix, getPrefixSize(l)), l.root === undefined ? undefined : mapNode(f, l.root, getDepth(l)), mapAffix(f, l.suffix, getSuffixSize(l)));\n}\nexport function pluck(key, l) {\n    return map(function (a) { return a[key]; }, l);\n}\nfunction foldlSuffix(f, acc, array, length) {\n    for (var i = 0; i < length; ++i) {\n        acc = f(acc, array[i]);\n    }\n    return acc;\n}\nfunction foldlPrefix(f, acc, array, length) {\n    for (var i = length - 1; 0 <= i; --i) {\n        acc = f(acc, array[i]);\n    }\n    return acc;\n}\nfunction foldlNode(f, acc, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldlSuffix(f, acc, array, array.length);\n    }\n    for (var i = 0; i < array.length; ++i) {\n        acc = foldlNode(f, acc, array[i], depth - 1);\n    }\n    return acc;\n}\nexport function foldl(f, initial, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    initial = foldlPrefix(f, initial, l.prefix, prefixSize);\n    if (l.root !== undefined) {\n        initial = foldlNode(f, initial, l.root, getDepth(l));\n    }\n    return foldlSuffix(f, initial, l.suffix, suffixSize);\n}\nexport var reduce = foldl;\nexport function traverse(of, f, l) {\n    return foldr(function (a, fl) {\n        return fl[\"fantasy-land/ap\"](f(a)[\"fantasy-land/map\"](function (a) { return function (l) { return prepend(a, l); }; }));\n    }, of[\"fantasy-land/of\"](empty()), l);\n}\nexport function sequence(ofObj, l) {\n    return traverse(ofObj, function (a) { return a; }, l);\n}\nexport function scan(f, initial, l) {\n    return foldl(function (l2, a) { return push(f(last(l2), a), l2); }, push(initial, emptyPushable()), l);\n}\nexport function forEach(callback, l) {\n    foldl(function (_, element) { return callback(element); }, undefined, l);\n}\nexport function filter(predicate, l) {\n    return foldl(function (acc, a) { return (predicate(a) ? push(a, acc) : acc); }, emptyPushable(), l);\n}\nexport function reject(predicate, l) {\n    return foldl(function (acc, a) { return (predicate(a) ? acc : push(a, acc)); }, emptyPushable(), l);\n}\nexport function partition(predicate, l) {\n    return foldl(function (arr, a) { return (predicate(a) ? push(a, arr[0]) : push(a, arr[1]), arr); }, [emptyPushable(), emptyPushable()], l);\n}\nexport function join(separator, l) {\n    return foldl(function (a, b) { return (a.length === 0 ? b : a + separator + b); }, \"\", l);\n}\nfunction foldrSuffix(f, initial, array, length) {\n    var acc = initial;\n    for (var i = length - 1; 0 <= i; --i) {\n        acc = f(array[i], acc);\n    }\n    return acc;\n}\nfunction foldrPrefix(f, initial, array, length) {\n    var acc = initial;\n    for (var i = 0; i < length; ++i) {\n        acc = f(array[i], acc);\n    }\n    return acc;\n}\nfunction foldrNode(f, initial, _a, depth) {\n    var array = _a.array;\n    if (depth === 0) {\n        return foldrSuffix(f, initial, array, array.length);\n    }\n    var acc = initial;\n    for (var i = array.length - 1; 0 <= i; --i) {\n        acc = foldrNode(f, acc, array[i], depth - 1);\n    }\n    return acc;\n}\nexport function foldr(f, initial, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    var acc = foldrSuffix(f, initial, l.suffix, suffixSize);\n    if (l.root !== undefined) {\n        acc = foldrNode(f, acc, l.root, getDepth(l));\n    }\n    return foldrPrefix(f, acc, l.prefix, prefixSize);\n}\nexport var reduceRight = foldr;\nexport function ap(listF, l) {\n    return flatten(map(function (f) { return map(f, l); }, listF));\n}\nexport function flatten(nested) {\n    return foldl(concat, empty(), nested);\n}\nexport function flatMap(f, l) {\n    return flatten(map(f, l));\n}\nexport var chain = flatMap;\nfunction foldlArrayCb(cb, state, array, from, to) {\n    for (var i = from; i < to && cb(array[i], state); ++i) { }\n    return i === to;\n}\nfunction foldrArrayCb(cb, state, array, from, to) {\n    for (var i = from - 1; to <= i && cb(array[i], state); --i) { }\n    return i === to - 1;\n}\nfunction foldlNodeCb(cb, state, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldlArrayCb(cb, state, array, 0, array.length);\n    }\n    var to = array.length;\n    for (var i = 0; i < to; ++i) {\n        if (!foldlNodeCb(cb, state, array[i], depth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction foldlCb(cb, state, l) {\n    var prefixSize = getPrefixSize(l);\n    if (!foldrArrayCb(cb, state, l.prefix, prefixSize, 0) ||\n        (l.root !== undefined && !foldlNodeCb(cb, state, l.root, getDepth(l)))) {\n        return state;\n    }\n    var suffixSize = getSuffixSize(l);\n    foldlArrayCb(cb, state, l.suffix, 0, suffixSize);\n    return state;\n}\nfunction foldrNodeCb(cb, state, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldrArrayCb(cb, state, array, array.length, 0);\n    }\n    for (var i = array.length - 1; 0 <= i; --i) {\n        if (!foldrNodeCb(cb, state, array[i], depth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction foldrCb(cb, state, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    if (!foldrArrayCb(cb, state, l.suffix, suffixSize, 0) ||\n        (l.root !== undefined && !foldrNodeCb(cb, state, l.root, getDepth(l)))) {\n        return state;\n    }\n    var prefix = l.prefix;\n    foldlArrayCb(cb, state, l.prefix, prefix.length - prefixSize, prefix.length);\n    return state;\n}\nfunction foldlWhileCb(a, state) {\n    if (state.predicate(state.result, a) === false) {\n        return false;\n    }\n    state.result = state.f(state.result, a);\n    return true;\n}\nexport function foldlWhile(predicate, f, initial, l) {\n    return foldlCb(foldlWhileCb, { predicate: predicate, f: f, result: initial }, l).result;\n}\nexport var reduceWhile = foldlWhile;\nfunction everyCb(value, state) {\n    return (state.result = state.predicate(value));\n}\nexport function every(predicate, l) {\n    return foldlCb(everyCb, { predicate: predicate, result: true }, l).result;\n}\nexport var all = every;\nfunction someCb(value, state) {\n    return !(state.result = state.predicate(value));\n}\nexport function some(predicate, l) {\n    return foldlCb(someCb, { predicate: predicate, result: false }, l).result;\n}\nexport var any = some;\nexport function none(predicate, l) {\n    return !some(predicate, l);\n}\nfunction findCb(value, state) {\n    if (state.predicate(value)) {\n        state.result = value;\n        return false;\n    }\n    else {\n        return true;\n    }\n}\nexport function find(predicate, l) {\n    return foldlCb(findCb, { predicate: predicate, result: undefined }, l)\n        .result;\n}\nexport function findLast(predicate, l) {\n    return foldrCb(findCb, { predicate: predicate, result: undefined }, l)\n        .result;\n}\nfunction indexOfCb(value, state) {\n    ++state.index;\n    return !(state.found = elementEquals(value, state.element));\n}\nexport function indexOf(element, l) {\n    var state = { element: element, found: false, index: -1 };\n    foldlCb(indexOfCb, state, l);\n    return state.found ? state.index : -1;\n}\nexport function lastIndexOf(element, l) {\n    var state = { element: element, found: false, index: 0 };\n    foldrCb(indexOfCb, state, l);\n    return state.found ? l.length - state.index : -1;\n}\nfunction findIndexCb(value, state) {\n    ++state.index;\n    return !(state.found = state.predicate(value));\n}\nexport function findIndex(predicate, l) {\n    var _a = foldlCb(findIndexCb, { predicate: predicate, found: false, index: -1 }, l), found = _a.found, index = _a.index;\n    return found ? index : -1;\n}\nvar containsState = {\n    element: undefined,\n    result: false\n};\nfunction containsCb(value, state) {\n    return !(state.result = value === state.element);\n}\nexport function includes(element, l) {\n    containsState.element = element;\n    containsState.result = false;\n    return foldlCb(containsCb, containsState, l).result;\n}\nexport var contains = includes;\nfunction equalsCb(value2, state) {\n    var value = state.iterator.next().value;\n    return (state.equals = state.f(value, value2));\n}\nexport function equals(l1, l2) {\n    return equalsWith(elementEquals, l1, l2);\n}\nexport function equalsWith(f, l1, l2) {\n    if (l1 === l2) {\n        return true;\n    }\n    else if (l1.length !== l2.length) {\n        return false;\n    }\n    else {\n        var s = { iterator: l2[Symbol.iterator](), equals: true, f: f };\n        return foldlCb(equalsCb, s, l1).equals;\n    }\n}\nvar eMax = 2;\nfunction createConcatPlan(array) {\n    var sizes = [];\n    var sum = 0;\n    for (var i_2 = 0; i_2 < array.length; ++i_2) {\n        sum += array[i_2].array.length;\n        sizes[i_2] = array[i_2].array.length;\n    }\n    var optimalLength = Math.ceil(sum / branchingFactor);\n    var n = array.length;\n    var i = 0;\n    if (optimalLength + eMax >= n) {\n        return undefined;\n    }\n    while (optimalLength + eMax < n) {\n        while (sizes[i] > branchingFactor - eMax / 2) {\n            ++i;\n        }\n        var remaining = sizes[i];\n        do {\n            var size = Math.min(remaining + sizes[i + 1], branchingFactor);\n            sizes[i] = size;\n            remaining = remaining - (size - sizes[i + 1]);\n            ++i;\n        } while (remaining > 0);\n        for (var j = i; j <= n - 1; ++j) {\n            sizes[j] = sizes[j + 1];\n        }\n        --i;\n        --n;\n    }\n    sizes.length = n;\n    return sizes;\n}\nfunction concatNodeMerge(left, center, right) {\n    var array = [];\n    if (left !== undefined) {\n        for (var i = 0; i < left.array.length - 1; ++i) {\n            array.push(left.array[i]);\n        }\n    }\n    for (var i = 0; i < center.array.length; ++i) {\n        array.push(center.array[i]);\n    }\n    if (right !== undefined) {\n        for (var i = 1; i < right.array.length; ++i) {\n            array.push(right.array[i]);\n        }\n    }\n    return array;\n}\nfunction executeConcatPlan(merged, plan, height) {\n    var result = [];\n    var sourceIdx = 0;\n    var offset = 0;\n    for (var _i = 0, plan_1 = plan; _i < plan_1.length; _i++) {\n        var toMove = plan_1[_i];\n        var source = merged[sourceIdx].array;\n        if (toMove === source.length && offset === 0) {\n            result.push(merged[sourceIdx]);\n            ++sourceIdx;\n        }\n        else {\n            var node = new Node(undefined, []);\n            while (toMove > 0) {\n                var available = source.length - offset;\n                var itemsToCopy = Math.min(toMove, available);\n                pushElements(source, node.array, offset, itemsToCopy);\n                if (toMove >= available) {\n                    ++sourceIdx;\n                    source = merged[sourceIdx].array;\n                    offset = 0;\n                }\n                else {\n                    offset += itemsToCopy;\n                }\n                toMove -= itemsToCopy;\n            }\n            if (height > 1) {\n                setSizes(node, height - 1);\n            }\n            result.push(node);\n        }\n    }\n    return result;\n}\nfunction rebalance(left, center, right, height, top) {\n    var merged = concatNodeMerge(left, center, right);\n    var plan = createConcatPlan(merged);\n    var balanced = plan !== undefined ? executeConcatPlan(merged, plan, height) : merged;\n    if (balanced.length <= branchingFactor) {\n        if (top === true) {\n            return new Node(undefined, balanced);\n        }\n        else {\n            return new Node(undefined, [\n                setSizes(new Node(undefined, balanced), height)\n            ]);\n        }\n    }\n    else {\n        return new Node(undefined, [\n            setSizes(new Node(undefined, balanced.slice(0, branchingFactor)), height),\n            setSizes(new Node(undefined, balanced.slice(branchingFactor)), height)\n        ]);\n    }\n}\nfunction concatSubTree(left, lDepth, right, rDepth, isTop) {\n    if (lDepth > rDepth) {\n        var c = concatSubTree(arrayLast(left.array), lDepth - 1, right, rDepth, false);\n        return rebalance(left, c, undefined, lDepth, isTop);\n    }\n    else if (lDepth < rDepth) {\n        var c = concatSubTree(left, lDepth, arrayFirst(right.array), rDepth - 1, false);\n        return rebalance(undefined, c, right, rDepth, isTop);\n    }\n    else if (lDepth === 0) {\n        return new Node(undefined, [left, right]);\n    }\n    else {\n        var c = concatSubTree(arrayLast(left.array), lDepth - 1, arrayFirst(right.array), rDepth - 1, false);\n        return rebalance(left, c, right, lDepth, isTop);\n    }\n}\nfunction getHeight(node) {\n    if (node.array[0] instanceof Node) {\n        return 1 + getHeight(node.array[0]);\n    }\n    else {\n        return 0;\n    }\n}\nfunction appendNodeToTree(l, array) {\n    if (l.root === undefined) {\n        if (getPrefixSize(l) === 0) {\n            l.bits = setPrefix(array.length, l.bits);\n            l.prefix = reverseArray(array);\n        }\n        else {\n            l.root = new Node(undefined, array);\n        }\n        return l;\n    }\n    var depth = getDepth(l);\n    var index = handleOffset(depth, l.offset, l.length - 1 - getPrefixSize(l));\n    var nodesToCopy = 0;\n    var nodesVisited = 0;\n    var shift = depth * 5;\n    var currentNode = l.root;\n    if (Math.pow(32, (depth + 1)) < index) {\n        shift = 0;\n        nodesVisited = depth;\n    }\n    while (shift > 5) {\n        var childIndex = void 0;\n        if (currentNode.sizes === undefined) {\n            childIndex = (index >> shift) & mask;\n            index &= ~(mask << shift);\n        }\n        else {\n            childIndex = currentNode.array.length - 1;\n            index -= currentNode.sizes[childIndex - 1];\n        }\n        nodesVisited++;\n        if (childIndex < mask) {\n            nodesToCopy = nodesVisited;\n        }\n        currentNode = currentNode.array[childIndex];\n        if (currentNode === undefined) {\n            nodesToCopy = nodesVisited;\n            shift = 5;\n        }\n        shift -= 5;\n    }\n    if (shift !== 0) {\n        nodesVisited++;\n        if (currentNode.array.length < branchingFactor) {\n            nodesToCopy = nodesVisited;\n        }\n    }\n    var node = new Node(undefined, array);\n    if (nodesToCopy === 0) {\n        var newPath = nodesVisited === 0 ? node : createPath(nodesVisited, node);\n        var newRoot = new Node(undefined, [l.root, newPath]);\n        l.root = newRoot;\n        l.bits = incrementDepth(l.bits);\n    }\n    else {\n        var copiedNode = copyFirstK(l, nodesToCopy, array.length);\n        copiedNode.array.push(createPath(depth - nodesToCopy, node));\n    }\n    return l;\n}\nfunction copyFirstK(newList, k, leafSize) {\n    var currentNode = cloneNode(newList.root);\n    newList.root = currentNode;\n    for (var i = 1; i < k; ++i) {\n        var index = currentNode.array.length - 1;\n        if (currentNode.sizes !== undefined) {\n            currentNode.sizes[index] += leafSize;\n        }\n        var newNode = cloneNode(currentNode.array[index]);\n        currentNode.array[index] = newNode;\n        currentNode = newNode;\n    }\n    if (currentNode.sizes !== undefined) {\n        currentNode.sizes.push(arrayLast(currentNode.sizes) + leafSize);\n    }\n    return currentNode;\n}\nvar concatBuffer = new Array(3);\nfunction concatAffixes(left, right) {\n    var nr = 0;\n    var arrIdx = 0;\n    var i = 0;\n    var length = getSuffixSize(left);\n    concatBuffer[nr] = [];\n    for (i = 0; i < length; ++i) {\n        concatBuffer[nr][arrIdx++] = left.suffix[i];\n    }\n    length = getPrefixSize(right);\n    for (i = 0; i < length; ++i) {\n        if (arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n        concatBuffer[nr][arrIdx++] = right.prefix[length - 1 - i];\n    }\n    length = getSuffixSize(right);\n    for (i = 0; i < length; ++i) {\n        if (arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n        concatBuffer[nr][arrIdx++] = right.suffix[i];\n    }\n    return nr;\n}\nexport function concat(left, right) {\n    if (left.length === 0) {\n        return right;\n    }\n    else if (right.length === 0) {\n        return left;\n    }\n    var newSize = left.length + right.length;\n    var rightSuffixSize = getSuffixSize(right);\n    var newList = cloneList(left);\n    if (right.root === undefined) {\n        var nrOfAffixes = concatAffixes(left, right);\n        for (var i = 0; i < nrOfAffixes; ++i) {\n            newList = appendNodeToTree(newList, concatBuffer[i]);\n            newList.length += concatBuffer[i].length;\n            concatBuffer[i] = undefined;\n        }\n        newList.length = newSize;\n        newList.suffix = concatBuffer[nrOfAffixes];\n        newList.bits = setSuffix(concatBuffer[nrOfAffixes].length, newList.bits);\n        concatBuffer[nrOfAffixes] = undefined;\n        return newList;\n    }\n    else {\n        var leftSuffixSize = getSuffixSize(left);\n        if (leftSuffixSize > 0) {\n            newList = appendNodeToTree(newList, left.suffix.slice(0, leftSuffixSize));\n            newList.length += leftSuffixSize;\n        }\n        newList = appendNodeToTree(newList, right.prefix.slice(0, getPrefixSize(right)).reverse());\n        var newNode = concatSubTree(newList.root, getDepth(newList), right.root, getDepth(right), true);\n        var newDepth = getHeight(newNode);\n        setSizes(newNode, newDepth);\n        newList.root = newNode;\n        newList.offset &= ~(mask << (getDepth(left) * branchBits));\n        newList.length = newSize;\n        newList.bits = setSuffix(rightSuffixSize, setDepth(newDepth, newList.bits));\n        newList.suffix = right.suffix;\n        return newList;\n    }\n}\nexport function update(index, a, l) {\n    if (index < 0 || l.length <= index) {\n        return l;\n    }\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    var newList = cloneList(l);\n    if (index < prefixSize) {\n        var newPrefix = copyArray(newList.prefix);\n        newPrefix[newPrefix.length - index - 1] = a;\n        newList.prefix = newPrefix;\n    }\n    else if (index >= l.length - suffixSize) {\n        var newSuffix = copyArray(newList.suffix);\n        newSuffix[index - (l.length - suffixSize)] = a;\n        newList.suffix = newSuffix;\n    }\n    else {\n        newList.root = updateNode(l.root, getDepth(l), index - prefixSize, l.offset, a);\n    }\n    return newList;\n}\nexport function adjust(index, f, l) {\n    if (index < 0 || l.length <= index) {\n        return l;\n    }\n    return update(index, f(nth(index, l)), l);\n}\nvar newAffix;\nfunction sliceNode(node, index, depth, pathLeft, pathRight, childLeft, childRight) {\n    var array = node.array.slice(pathLeft, pathRight + 1);\n    if (childLeft !== undefined) {\n        array[0] = childLeft;\n    }\n    if (childRight !== undefined) {\n        array[array.length - 1] = childRight;\n    }\n    var sizes = node.sizes;\n    if (sizes !== undefined) {\n        sizes = sizes.slice(pathLeft, pathRight + 1);\n        var slicedOffLeft = pathLeft !== 0 ? node.sizes[pathLeft - 1] : 0;\n        if (childLeft !== undefined) {\n            if (childLeft.sizes !== undefined) {\n                var oldChild = node.array[pathLeft];\n                slicedOffLeft +=\n                    arrayLast(oldChild.sizes) - arrayLast(childLeft.sizes);\n            }\n            else {\n                slicedOffLeft += ((index - slicedOffLeft) & ~31) + 32;\n            }\n        }\n        for (var i = 0; i < sizes.length; ++i) {\n            sizes[i] -= slicedOffLeft;\n        }\n        if (childRight !== undefined) {\n            var slicedOffRight = sizeOfSubtree(node.array[pathRight], depth - 1) -\n                sizeOfSubtree(childRight, depth - 1);\n            sizes[sizes.length - 1] -= slicedOffRight;\n        }\n    }\n    return new Node(sizes, array);\n}\nvar newOffset = 0;\nfunction sliceLeft(tree, depth, index, offset, top) {\n    var _a = getPath(index, offset, depth, tree.sizes), path = _a.path, newIndex = _a.index, updatedOffset = _a.updatedOffset;\n    if (depth === 0) {\n        newAffix = tree.array.slice(path).reverse();\n        return undefined;\n    }\n    else {\n        var child = sliceLeft(tree.array[path], depth - 1, newIndex, updatedOffset, false);\n        if (child === undefined) {\n            ++path;\n            if (path === tree.array.length) {\n                return undefined;\n            }\n        }\n        if (tree.sizes === undefined && top === false) {\n            newOffset |= (32 - (tree.array.length - path)) << (depth * branchBits);\n        }\n        return sliceNode(tree, index, depth, path, tree.array.length - 1, child, undefined);\n    }\n}\nfunction sliceRight(node, depth, index, offset) {\n    var _a = getPath(index, offset, depth, node.sizes), path = _a.path, newIndex = _a.index;\n    if (depth === 0) {\n        newAffix = node.array.slice(0, path + 1);\n        return undefined;\n    }\n    else {\n        var child = sliceRight(node.array[path], depth - 1, newIndex, path === 0 ? offset : 0);\n        if (child === undefined) {\n            --path;\n            if (path === -1) {\n                return undefined;\n            }\n        }\n        var array = node.array.slice(0, path + 1);\n        if (child !== undefined) {\n            array[array.length - 1] = child;\n        }\n        var sizes = node.sizes;\n        if (sizes !== undefined) {\n            sizes = sizes.slice(0, path + 1);\n            if (child !== undefined) {\n                var slicedOff = sizeOfSubtree(node.array[path], depth - 1) -\n                    sizeOfSubtree(child, depth - 1);\n                sizes[sizes.length - 1] -= slicedOff;\n            }\n        }\n        return new Node(sizes, array);\n    }\n}\nfunction sliceTreeList(from, to, tree, depth, offset, l) {\n    var sizes = tree.sizes;\n    var _a = getPath(from, offset, depth, sizes), pathLeft = _a.path, newFrom = _a.index;\n    var _b = getPath(to, offset, depth, sizes), pathRight = _b.path, newTo = _b.index;\n    if (depth === 0) {\n        l.prefix = emptyAffix;\n        l.suffix = tree.array.slice(pathLeft, pathRight + 1);\n        l.root = undefined;\n        l.bits = setSuffix(pathRight - pathLeft + 1, 0);\n        return l;\n    }\n    else if (pathLeft === pathRight) {\n        l.bits = decrementDepth(l.bits);\n        return sliceTreeList(newFrom, newTo, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);\n    }\n    else {\n        var childRight = sliceRight(tree.array[pathRight], depth - 1, newTo, 0);\n        l.bits = setSuffix(newAffix.length, l.bits);\n        l.suffix = newAffix;\n        if (childRight === undefined) {\n            --pathRight;\n        }\n        newOffset = 0;\n        var childLeft = sliceLeft(tree.array[pathLeft], depth - 1, newFrom, pathLeft === 0 ? offset : 0, pathLeft === pathRight);\n        l.offset = newOffset;\n        l.bits = setPrefix(newAffix.length, l.bits);\n        l.prefix = newAffix;\n        if (childLeft === undefined) {\n            ++pathLeft;\n        }\n        if (pathLeft >= pathRight) {\n            if (pathLeft > pathRight) {\n                l.bits = setDepth(0, l.bits);\n                l.root = undefined;\n            }\n            else {\n                l.bits = decrementDepth(l.bits);\n                var newRoot = childRight !== undefined\n                    ? childRight\n                    : childLeft !== undefined\n                        ? childLeft\n                        : tree.array[pathLeft];\n                l.root = new Node(newRoot.sizes, newRoot.array);\n            }\n        }\n        else {\n            l.root = sliceNode(tree, from, depth, pathLeft, pathRight, childLeft, childRight);\n        }\n        return l;\n    }\n}\nexport function slice(from, to, l) {\n    var bits = l.bits, length = l.length;\n    to = Math.min(length, to);\n    if (from < 0) {\n        from = length + from;\n    }\n    if (to < 0) {\n        to = length + to;\n    }\n    if (to <= from || to <= 0 || length <= from) {\n        return empty();\n    }\n    if (from <= 0 && length <= to) {\n        return l;\n    }\n    var newLength = to - from;\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    if (to <= prefixSize) {\n        return new List(setPrefix(newLength, 0), 0, newLength, l.prefix.slice(prefixSize - to, prefixSize - from), undefined, emptyAffix);\n    }\n    var suffixStart = length - suffixSize;\n    if (suffixStart <= from) {\n        return new List(setSuffix(newLength, 0), 0, newLength, emptyAffix, undefined, l.suffix.slice(from - suffixStart, to - suffixStart));\n    }\n    var newList = cloneList(l);\n    newList.length = newLength;\n    if (prefixSize <= from && to <= suffixStart) {\n        sliceTreeList(from - prefixSize + l.offset, to - prefixSize + l.offset - 1, l.root, getDepth(l), l.offset, newList);\n        return newList;\n    }\n    if (0 < from) {\n        if (from < prefixSize) {\n            newList.prefix = l.prefix.slice(0, prefixSize - from);\n            bits = setPrefix(prefixSize - from, bits);\n        }\n        else {\n            newOffset = 0;\n            newList.root = sliceLeft(newList.root, getDepth(l), from - prefixSize, l.offset, true);\n            newList.offset = newOffset;\n            if (newList.root === undefined) {\n                bits = setDepth(0, bits);\n            }\n            bits = setPrefix(newAffix.length, bits);\n            prefixSize = newAffix.length;\n            newList.prefix = newAffix;\n        }\n    }\n    if (to < length) {\n        if (length - to < suffixSize) {\n            bits = setSuffix(suffixSize - (length - to), bits);\n            newList.suffix = l.suffix.slice(0, suffixSize - (length - to));\n        }\n        else {\n            newList.root = sliceRight(newList.root, getDepth(l), to - prefixSize - 1, newList.offset);\n            if (newList.root === undefined) {\n                bits = setDepth(0, bits);\n                newList.offset = 0;\n            }\n            bits = setSuffix(newAffix.length, bits);\n            newList.suffix = newAffix;\n        }\n    }\n    newList.bits = bits;\n    return newList;\n}\nexport function take(n, l) {\n    return slice(0, n, l);\n}\nfunction findNotIndexCb(value, state) {\n    if (state.predicate(value)) {\n        ++state.index;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function takeWhile(predicate, l) {\n    var index = foldlCb(findNotIndexCb, { predicate: predicate, index: 0 }, l).index;\n    return slice(0, index, l);\n}\nexport function takeLastWhile(predicate, l) {\n    var index = foldrCb(findNotIndexCb, { predicate: predicate, index: 0 }, l).index;\n    return slice(l.length - index, l.length, l);\n}\nexport function dropWhile(predicate, l) {\n    var index = foldlCb(findNotIndexCb, { predicate: predicate, index: 0 }, l).index;\n    return slice(index, l.length, l);\n}\nexport function dropRepeats(l) {\n    return dropRepeatsWith(elementEquals, l);\n}\nexport function dropRepeatsWith(predicate, l) {\n    return foldl(function (acc, a) {\n        return acc.length !== 0 && predicate(last(acc), a) ? acc : push(a, acc);\n    }, emptyPushable(), l);\n}\nexport function takeLast(n, l) {\n    return slice(l.length - n, l.length, l);\n}\nexport function splitAt(index, l) {\n    return [slice(0, index, l), slice(index, l.length, l)];\n}\nexport function splitWhen(predicate, l) {\n    var idx = findIndex(predicate, l);\n    return idx === -1 ? [l, empty()] : splitAt(idx, l);\n}\nexport function splitEvery(size, l) {\n    var _a = foldl(function (_a, elm) {\n        var l2 = _a.l2, buffer = _a.buffer;\n        push(elm, buffer);\n        if (buffer.length === size) {\n            return { l2: push(buffer, l2), buffer: emptyPushable() };\n        }\n        else {\n            return { l2: l2, buffer: buffer };\n        }\n    }, { l2: emptyPushable(), buffer: emptyPushable() }, l), l2 = _a.l2, buffer = _a.buffer;\n    return buffer.length === 0 ? l2 : push(buffer, l2);\n}\nexport function remove(from, amount, l) {\n    return concat(slice(0, from, l), slice(from + amount, l.length, l));\n}\nexport function drop(n, l) {\n    return slice(n, l.length, l);\n}\nexport function dropLast(n, l) {\n    return slice(0, l.length - n, l);\n}\nexport function pop(l) {\n    return slice(0, -1, l);\n}\nexport var init = pop;\nexport function tail(l) {\n    return slice(1, l.length, l);\n}\nfunction arrayPush(array, a) {\n    array.push(a);\n    return array;\n}\nexport function toArray(l) {\n    return foldl(arrayPush, [], l);\n}\nexport function insert(index, element, l) {\n    return concat(append(element, slice(0, index, l)), slice(index, l.length, l));\n}\nexport function insertAll(index, elements, l) {\n    return concat(concat(slice(0, index, l), elements), slice(index, l.length, l));\n}\nexport function reverse(l) {\n    return foldl(function (newL, element) { return prepend(element, newL); }, empty(), l);\n}\nexport function isList(l) {\n    return typeof l === \"object\" && Array.isArray(l.suffix);\n}\nexport function zip(as, bs) {\n    return zipWith(function (a, b) { return [a, b]; }, as, bs);\n}\nexport function zipWith(f, as, bs) {\n    var swapped = bs.length < as.length;\n    var iterator = (swapped ? as : bs)[Symbol.iterator]();\n    return map(function (a) {\n        var b = iterator.next().value;\n        return swapped ? f(b, a) : f(a, b);\n    }, (swapped ? bs : as));\n}\nfunction isPrimitive(value) {\n    return typeof value === \"number\" || typeof value === \"string\";\n}\nfunction comparePrimitive(a, b) {\n    return a === b ? 0 : a < b ? -1 : 1;\n}\nvar ord = \"fantasy-land/lte\";\nfunction compareOrd(a, b) {\n    return a[ord](b) ? (b[ord](a) ? 0 : -1) : 1;\n}\nexport function sort(l) {\n    if (l.length === 0) {\n        return l;\n    }\n    else if (isPrimitive(first(l))) {\n        return from(toArray(l).sort(comparePrimitive));\n    }\n    else {\n        return sortWith(compareOrd, l);\n    }\n}\nexport function sortWith(comparator, l) {\n    var arr = [];\n    var i = 0;\n    forEach(function (elm) { return arr.push({ idx: i++, elm: elm }); }, l);\n    arr.sort(function (_a, _b) {\n        var a = _a.elm, i = _a.idx;\n        var b = _b.elm, j = _b.idx;\n        var c = comparator(a, b);\n        return c !== 0 ? c : i < j ? -1 : 1;\n    });\n    var newL = emptyPushable();\n    for (var i_3 = 0; i_3 < arr.length; ++i_3) {\n        push(arr[i_3].elm, newL);\n    }\n    return newL;\n}\nexport function sortBy(f, l) {\n    if (l.length === 0) {\n        return l;\n    }\n    var arr = [];\n    var i = 0;\n    forEach(function (elm) { return arr.push({ idx: i++, elm: elm, prop: f(elm) }); }, l);\n    var comparator = isPrimitive(arr[0].prop)\n        ? comparePrimitive\n        : compareOrd;\n    arr.sort(function (_a, _b) {\n        var a = _a.prop, i = _a.idx;\n        var b = _b.prop, j = _b.idx;\n        var c = comparator(a, b);\n        return c !== 0 ? c : i < j ? -1 : 1;\n    });\n    var newL = emptyPushable();\n    for (var i_4 = 0; i_4 < arr.length; ++i_4) {\n        push(arr[i_4].elm, newL);\n    }\n    return newL;\n}\nexport function group(l) {\n    return groupWith(elementEquals, l);\n}\nexport function groupWith(f, l) {\n    var result = emptyPushable();\n    var buffer = emptyPushable();\n    forEach(function (a) {\n        if (buffer.length !== 0 && !f(last(buffer), a)) {\n            push(buffer, result);\n            buffer = emptyPushable();\n        }\n        push(a, buffer);\n    }, l);\n    return buffer.length === 0 ? result : push(buffer, result);\n}\nexport function intersperse(separator, l) {\n    return pop(foldl(function (l2, a) { return push(separator, push(a, l2)); }, emptyPushable(), l));\n}\nexport function isEmpty(l) {\n    return l.length === 0;\n}\n"],
  "mappings": "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",
  "names": ["d", "b", "length", "Node", "List", "length", "ListIterator", "ForwardListIterator", "BackwardsListIterator", "first", "sequence", "list", "times", "length", "newOffset", "of", "a", "l", "from", "_a", "l2", "buffer", "i"]
}
